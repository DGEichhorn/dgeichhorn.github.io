---
title: "Learning to Rank"
description: "In this post, I implement from scratch two different approaches for learning a ranking from data on the results of pairwise comparisons."
author: "Alicia"
date: "5/22/2021"
image: "cover.jpg"
categories:
  - Science
  - Technology
---

# TO DO

1. 2mal metric für vergleich meine lösung vs. package
2. plots zum vergleich der beiden rankings (u.a. plot(log(bt_mle), r))



I am trying to implement various ranking approaches.

# Get pairwise comparison data

get American Football data from <https://www.pro-football-reference.com/years/2024/games.htm>; OLD NHL: <https://www.hockey-reference.com/leagues/NHL_2025_games.html#games>

```{r}
#| warning: false

library(rvest)        # for web page scraping
library(dplyr)        # for data manipulations
library(ggplot2)      # for visualization

url <- "https://www.pro-football-reference.com/years/2024/games.htm#games"
page <- read_html(url)

games <- page %>%
  html_node("table#games") %>%
  html_table(header=TRUE) %>%
  as.data.frame()

games <- games[, c(1,5,7)]
names(games) <- c("Week", "Winner", "Loser")

# keep only games during regular season (i.e. int-valued week)
games <- games %>%
  filter(grepl("^[0-9]+$", Week)) %>%
  select(Winner, Loser)

teams <- sort(unique(c(games$Winner, games$Loser)))
n_teams <- length(teams)
```

# Construct Win Matrix from pairwise comparisons data

adjacency matrix $W=[w_{ij}]_{i=1,\dots,n,\, j=1,\dots, n}$ i.e. i-th row says how often team i won against every other team

```{r}
# initialize win matrix with zeros
W <- matrix(
  rep(0, n_teams^2),
  nrow = n_teams,
  dimnames = list(
    teams, # row names
    teams  # col names
  )
)

# fill win matrix
# iterate over all games
for (g in 1:dim(games)[1]) {
  W[games[g, "Winner"], games[g, "Loser"]] <- 
    W[games[g, "Winner"], games[g, "Loser"]] + 1
}

```

# Define function for mle estimation of Bradley Terry Model

```{r}
bradleyterry_mle <- function(W, n_iter=1000){
  p <- dim(W)[1]
  
  theta.old <- rep(1, p)
  names(theta.old) <- colnames(W)
  
  theta.new <- numeric(p)
  names(theta.new) <- colnames(W)
  
  for (k in 1:n_iter) {
    
    for (i in 1:p) {
      theta.new[i] <- 
        sum(W[i,])/(sum((W[i,] + W[,i])/(theta.old[i]+theta.old)))
    }
    
    # divide by geomtric mean
    theta.new <- theta.new/prod(theta.new)^(1/p)
    
    theta.old <- theta.new
  }
  
  return(theta.new)
}
```

apply mle estimation function to W matrix

```{r}
bt_mle <- bradleyterry_mle(W)
```

# Plot ranking results

```{r}
df <- data.frame(
  team = names(bt_mle),
  score = as.numeric(bt_mle)
)

ggplot(df, aes(reorder(team, score), y=score)) +
  geom_col(fill="steelblue") +
  coord_flip() +
  labs(title="TITEL",
       y="y ACHSE",
       x="x ACHSE") +
  theme_minimal()
```

# compare my results to results of R Package Bradley Terry

```{r}
#| warning: false

# evtl nicht die ganze library laden sondern nur BradleyTerry2:: an den notwendigen Stellen nutzen
library(BradleyTerry2)

b<-countsToBinomial(W)
package_model <- BTm(cbind(win1, win2), player1, player2, data=b)
BTabilities(package_model)

# Converting my values into BTm ability values
log(bt_mle/bt_mle[1])


# Converting BTm values to my values
BTabilities <- BTabilities(package_model)[,1]
exp(BTabilities)*bt_mle[1]
```

# Google Page Rank from scratch

```{r}
#| warning: false

p <- n_teams

d <- 0.85

r <- rep(1/p, p)

# W_ij: number of times team j lost against team i
#W

# c_j: number of times team j lost (=colSums of W)

c <- colSums(W)

A <- (1-d)*rep(1,p) %*% t(rep(1,p))/p + d*W%*%diag(1/c) 

for (i in 1:100) {
  r <- A%*%r
}

print(r)
```
# compare my results to R Package results

wichtig: evtl. igraph:: verwenden anstatt gesamte library zu laden um klarer zu machen wo genau wir eigentlich was aus dieser library verwende

```{r}
library(igraph)

graphObj <- graph_from_adjacency_matrix(t(W), weighted = TRUE, mode = "directed")
(prVec <- page_rank(graphObj)$vector)
```


